# 订单服务集成服务适配器说明

## 📋 概述

本文档描述了订单服务中集成的各个服务适配器，这些适配器封装了与其他微服务的Dubbo调用，保持了订单服务的独立性和可维护性。

## 🔧 已实现的服务适配器

### 1. InventoryServiceAdapter - 库存服务适配器

**位置**: `com.mall.order.adapter.InventoryServiceAdapter`

**功能**:
- 批量检查库存可用性
- 批量锁定库存
- 扣减已锁定的库存
- 释放锁定的库存
- 退还库存（用于退货）
- 获取库存信息

**主要方法**:
```java
// 检查库存可用性
public void checkStockAvailability(List<OrderItem> items)

// 批量锁定库存
public List<StockLockVO> batchLockStock(List<OrderItem> items, String orderNo, Long userId)

// 扣减锁定库存
public void deductLockedStock(String orderNo)

// 释放锁定库存
public void unlockStock(String orderNo)

// 退还库存
public void returnStock(List<OrderItem> items, String orderNo)
```

### 2. UserServiceAdapter - 用户服务适配器

**位置**: `com.mall.order.adapter.UserServiceAdapter`

**功能**:
- 获取用户基本信息
- 获取收货地址信息
- 积分操作（扣减、退还、赠送）
- 成长值管理
- 余额操作
- 会员信息获取

**主要方法**:
```java
// 获取用户信息
public UserVO getUserInfo(Long userId)

// 获取地址信息
public AddressVO getAddress(Long addressId)

// 积分操作
public void deductPoints(Long userId, Integer points, String orderNo)
public void returnPoints(Long userId, Integer points, String orderNo)
public void awardPointsAndGrowth(Long userId, Integer points, Integer growth, String orderNo)

// 验证积分和余额
public boolean checkPointsSufficient(Long userId, Integer usePoints)
public boolean checkBalanceSufficient(Long userId, BigDecimal amount)
```

### 3. ProductServiceAdapter - 商品服务适配器

**位置**: `com.mall.order.adapter.ProductServiceAdapter`

**功能**:
- 批量获取SKU信息
- 校验商品状态
- 运费计算（简化版）
- 检查商品可用性

**主要方法**:
```java
// 获取商品信息
public Map<Long, SkuVO> getSkuInfoMap(List<Long> skuIds)
public SkuVO getSkuInfo(Long skuId)

// 校验商品
public void validateProductStatus(List<Long> skuIds)
public void checkProductAvailable(List<Long> skuIds)

// 运费计算
public BigDecimal calculateFreight(Long spuId, String provinceCode, String cityCode, Integer quantity)
```

### 4. PaymentServiceAdapter - 支付服务适配器

**位置**: `com.mall.order.adapter.PaymentServiceAdapter`

**功能**:
- 创建支付订单
- 查询支付状态
- 取消/关闭支付
- 验证支付信息

**主要方法**:
```java
// 创建支付
public PaymentResultVO createPayment(String orderNo, Long userId, Integer paymentType, 
                                   BigDecimal paymentAmount, String subject, String description,
                                   String returnUrl, String notifyUrl, LocalDateTime expireTime)

// 查询支付状态
public PaymentVO queryPaymentByOrderNo(String orderNo)

// 验证支付
public boolean isPaymentSuccess(String orderNo)
public boolean validatePaymentAmount(String orderNo, BigDecimal expectedAmount)
```

## 🔄 OrderServiceImpl的主要改进

### 1. 订单创建流程优化

**之前**:
```java
// 库存相关方法都被注释掉了
private void lockStock(List<OrderItem> items) {
    // TODO: 调用库存服务
}
```

**现在**:
```java
// 5. 校验商品可用性和库存
List<Long> skuIds = orderItems.stream()
        .map(OrderItem::getSkuId)
        .collect(Collectors.toList());
productServiceAdapter.checkProductAvailable(skuIds);
inventoryServiceAdapter.checkStockAvailability(orderItems);

// 6. 锁定库存
String orderNo = generateOrderNo();
inventoryServiceAdapter.batchLockStock(orderItems, orderNo, userId);

// 9. 扣减库存
inventoryServiceAdapter.deductLockedStock(order.getOrderNo());

// 11. 扣减积分
if (request.getUsePoints() != null && request.getUsePoints() > 0) {
    userServiceAdapter.deductPoints(userId, request.getUsePoints(), order.getOrderNo());
}
```

### 2. 订单取消流程优化

**之前**:
```java
// TODO: 调用用户服务退还积分
// TODO: 调用库存服务释放库存
```

**现在**:
```java
// 释放库存
inventoryServiceAdapter.unlockStock(order.getOrderNo());

// 退还积分
if (order.getUsePoints() != null && order.getUsePoints() > 0) {
    userServiceAdapter.returnPoints(order.getUserId(), order.getUsePoints(), order.getOrderNo());
}
```

### 3. 订单完成流程优化

**之前**:
```java
// TODO: 调用用户服务增加积分和成长值
```

**现在**:
```java
// 调用用户服务增加积分和成长值
userServiceAdapter.awardPointsAndGrowth(order.getUserId(), totalPoints, totalGrowth, order.getOrderNo());
```

### 4. 支付流程优化

**之前**:
```java
// 复杂的PaymentCreateRequest构建和Result处理
PaymentCreateRequest paymentRequest = new PaymentCreateRequest();
// ... 设置各种参数
Result<PaymentResultVO> paymentResult = paymentFeignClient.createPayment(paymentRequest);
if (!paymentResult.isSuccess()) {
    throw new BusinessException("Failed to create payment");
}
```

**现在**:
```java
// 简洁的适配器调用
PaymentResultVO paymentResult = paymentServiceAdapter.createPayment(
    order.getOrderNo(),
    order.getUserId(),
    request.getPaymentType(),
    order.getPayAmount(),
    "订单支付",
    "订单号：" + order.getOrderNo(),
    request.getReturnUrl(),
    request.getNotifyUrl(),
    order.getExpireTime()
);
```

## 📦 依赖配置

### Maven依赖 (pom.xml)

```xml
<!-- API模块依赖 -->
<dependency>
    <groupId>com.mall</groupId>
    <artifactId>user-api</artifactId>
    <version>${project.version}</version>
</dependency>

<dependency>
    <groupId>com.mall</groupId>
    <artifactId>product-api</artifactId>
    <version>${project.version}</version>
</dependency>

<dependency>
    <groupId>com.mall</groupId>
    <artifactId>inventory-api</artifactId>
    <version>${project.version}</version>
</dependency>

<dependency>
    <groupId>com.mall</groupId>
    <artifactId>payment-api</artifactId>
    <version>${project.version}</version>
</dependency>
```

### Dubbo配置 (application.yml)

```yaml
dubbo:
  application:
    name: ${spring.application.name}
    version: 1.0.0
  registry:
    address: nacos://${NACOS_SERVER_ADDR:localhost:8848}
    group: mall
    namespace: ${NACOS_NAMESPACE:public}
  protocol:
    name: dubbo
    port: ${DUBBO_PORT:20883}
    serialization: hessian2
  provider:
    group: mall
    version: 1.0.0
    timeout: 30000
    retries: 0
  consumer:
    group: mall
    version: 1.0.0
    timeout: 30000
    retries: 2
    check: false
  scan:
    base-packages: com.mall.order
```

## 🎯 优势和特点

### 1. 模块独立性
- 订单服务只依赖API定义，不依赖具体实现
- 服务适配器封装了复杂的Dubbo调用逻辑
- 便于单元测试和Mock

### 2. 错误处理
- 统一的异常处理机制
- 优雅的降级处理
- 详细的日志记录

### 3. 性能优化
- 批量操作减少网络调用
- 合理的超时和重试配置
- 异步处理非关键操作

### 4. 可维护性
- 清晰的方法命名和文档
- 统一的调用模式
- 易于扩展和修改

## 🚀 使用建议

1. **监控服务调用**: 添加适当的监控和日志
2. **性能调优**: 根据实际负载调整超时和重试参数
3. **异常处理**: 完善各种异常场景的处理逻辑
4. **缓存策略**: 对频繁查询的数据添加缓存
5. **熔断降级**: 配置Sentinel熔断规则

## 📝 注意事项

1. **依赖启动顺序**: 确保被调用的服务先启动
2. **网络配置**: 确保服务间网络连通性
3. **版本兼容**: 保持API版本的兼容性
4. **事务处理**: 注意分布式事务的一致性问题
5. **数据一致性**: 处理好并发场景下的数据一致性

## 🔮 后续优化计划

1. **补充缺失接口**: 
   - 优惠券服务接口
   - 运费计算接口
   - 物流跟踪接口

2. **性能优化**:
   - 引入异步处理
   - 批量操作优化
   - 缓存策略完善

3. **监控完善**:
   - 服务调用监控
   - 性能指标收集
   - 告警机制建立 